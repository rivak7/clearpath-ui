#!/usr/bin/env pwsh
Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# One-command runner (Windows PowerShell): ensures Node runtime, installs deps, optional tunnel, starts server

$HERE = Split-Path -Parent $MyInvocation.MyCommand.Path
Set-Location $HERE

# Ensure .env exists with sane defaults
$envPath = Join-Path $HERE '.env'
if (-not (Test-Path $envPath)) {
  @"
# Auto-generated by run.ps1
PORT=8080
HOST=0.0.0.0
# Expose a public URL by default
ENABLE_TUNNEL=1
# Use Cloudflare quick tunnel (no interstitial)
TUNNEL_PROVIDER=cloudflared
"@ | Out-File -FilePath $envPath -Encoding UTF8 -NoNewline
}

function Get-NodeMajorVersion {
  try {
    $v = & node -p "process.versions.node.split('.')[0]" 2>$null
    if ($LASTEXITCODE -ne 0 -or -not $v) { return 0 }
    return [int]$v
  } catch { return 0 }
}

$nodeBin = 'node'
$npmBin = 'npm'

if ((Get-NodeMajorVersion) -lt 18) {
  $runtimeDir = Join-Path $HERE '.runtime'
  New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
  $arch = $env:PROCESSOR_ARCHITECTURE
  if ($arch -match 'ARM64') { $ARCH = 'arm64' } else { $ARCH = 'x64' }
  $NODE_VER = 'v20.16.0'
  $zipName = "node-$NODE_VER-win-$ARCH.zip"
  $url = "https://nodejs.org/dist/$NODE_VER/$zipName"
  $destZip = Join-Path $runtimeDir $zipName
  $destDir = Join-Path $runtimeDir ("node-$NODE_VER-win-$ARCH")
  if (-not (Test-Path (Join-Path $destDir 'node.exe'))) {
    Write-Host "Downloading Node.js $NODE_VER (win-$ARCH)…"
    Invoke-WebRequest -Uri $url -OutFile $destZip -UseBasicParsing
    Write-Host 'Extracting…'
    if (Test-Path $destDir) { Remove-Item -Recurse -Force $destDir }
    Expand-Archive -Path $destZip -DestinationPath $runtimeDir -Force
    Remove-Item $destZip -Force
  }
  $env:Path = (Join-Path $destDir '') + ';' + $env:Path
  $nodeBin = Join-Path $destDir 'node.exe'
  $npmBin = Join-Path $destDir 'npm.cmd'
}

# Install dependencies if missing (idempotent)
if (-not (Test-Path (Join-Path $HERE 'node_modules'))) {
  Write-Host 'Installing Node dependencies…'
  & $npmBin install --omit=dev --no-fund --no-audit
}

# If tunneling is enabled, ensure provider binary exists in PATH
$enableTunnel = $false
try {
  $envLines = Get-Content -Path $envPath -ErrorAction SilentlyContinue
  if ($env:ENABLE_TUNNEL -eq '1' -or ($envLines -and ($envLines | Where-Object { $_ -match '^ENABLE_TUNNEL=1' }))) { $enableTunnel = $true }
} catch {}

if ($enableTunnel) {
  # Default to cloudflared
  $tp = if ($env:TUNNEL_PROVIDER) { $env:TUNNEL_PROVIDER.ToLower() } else {
    ($envLines | Where-Object { $_ -match '^TUNNEL_PROVIDER=' } | ForEach-Object { ($_ -split '=',2)[1] })
  }
  if (-not $tp) { $tp = 'cloudflared' }
  if ($tp -eq 'cloudflared') {
    $runtimeDir = Join-Path $HERE '.runtime'
    New-Item -ItemType Directory -Force -Path $runtimeDir | Out-Null
    $cfExe = Join-Path $runtimeDir 'cloudflared.exe'
    if (-not (Test-Path $cfExe)) {
      $arch = $env:PROCESSOR_ARCHITECTURE
      if ($arch -match 'ARM64') { $cfUrl = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-arm64.exe' }
      else { $cfUrl = 'https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-windows-amd64.exe' }
      Write-Host 'Downloading cloudflared…'
      Invoke-WebRequest -Uri $cfUrl -OutFile $cfExe -UseBasicParsing
    }
    $env:Path = (Join-Path $runtimeDir '') + ';' + $env:Path
  }
}

# Start server (dotenv in server.js will pick up .env)
& $nodeBin (Join-Path $HERE 'server.js')


