#!/usr/bin/env bash
set -euo pipefail

# One command runner: ensures Node runtime, installs deps if needed, and starts the server.
# Defaults to exposing a public tunnel so it is reachable from the internet.

HERE=$(cd "$(dirname "$0")" && pwd)
cd "$HERE"

# Ensure a .env exists with sane defaults (non-invasive if present)
if [[ ! -f .env ]]; then
  cat > .env <<'EOF'
# Auto-generated by ./run
PORT=8080
HOST=0.0.0.0
# Expose a public URL by default
ENABLE_TUNNEL=1
# Use Cloudflare quick tunnel (no interstitial)
TUNNEL_PROVIDER=cloudflared
EOF
fi

need_node_download() {
  if command -v node >/dev/null 2>&1; then
    # Require Node >= 18
    local major
    major=$(node -p "process.versions.node.split('.')[0]") || major=0
    if [[ ${major:-0} -ge 18 ]]; then
      return 1 # no download needed
    fi
  fi
  return 0 # need download
}

NODE_BIN="node"
NPM_BIN="npm"
if need_node_download; then
  mkdir -p .runtime
  OS="darwin"
  ARCH=$(uname -m)
  case "$ARCH" in
    arm64|aarch64) ARCH="arm64" ;;
    x86_64|amd64) ARCH="x64" ;;
    *) echo "Unsupported architecture: $ARCH" >&2; exit 1 ;;
  esac
  NODE_VER="v20.16.0"
  TARBALL="node-${NODE_VER}-${OS}-${ARCH}.tar.xz"
  URL="https://nodejs.org/dist/${NODE_VER}/${TARBALL}"
  DEST_DIR=".runtime/node-${NODE_VER}-${OS}-${ARCH}"
  if [[ ! -x "$DEST_DIR/bin/node" ]]; then
    echo "Downloading Node.js ${NODE_VER} (${OS}-${ARCH})…" >&2
    TMP=".runtime/${TARBALL}"
    curl -fsSL "$URL" -o "$TMP"
    echo "Extracting…" >&2
    tar -xJf "$TMP" -C .runtime
    mv ".runtime/node-${NODE_VER}-${OS}-${ARCH}" "$DEST_DIR" || true
    rm -f "$TMP"
  fi
  export PATH="$HERE/$DEST_DIR/bin:$PATH"
  NODE_BIN="$HERE/$DEST_DIR/bin/node"
  NPM_BIN="$HERE/$DEST_DIR/bin/npm"
fi

# Install dependencies if missing (non-destructive if already present)
if [[ ! -d node_modules ]] || [[ ! -f node_modules/express/package.json ]]; then
  echo "Installing Node dependencies…" >&2
  "$NPM_BIN" install --omit=dev --no-fund --no-audit
fi

# If tunneling is enabled, ensure the chosen provider's binary exists in PATH
if grep -q '^ENABLE_TUNNEL=1' .env || [[ "${ENABLE_TUNNEL:-}" == "1" ]]; then
  TP=${TUNNEL_PROVIDER:-}
  if [[ -z "$TP" ]]; then
    # Try read from .env without sourcing; tolerate missing key
    if [[ -f .env ]]; then
      TP=$(grep -E '^TUNNEL_PROVIDER=' .env 2>/dev/null | sed -E 's/^TUNNEL_PROVIDER=//' || true)
    fi
  fi
  # Default to cloudflared if unset (server.js also defaults to cloudflared)
  if [[ -z "$TP" ]]; then
    TP="cloudflared"
  fi
  if [[ "$TP" == "cloudflared" ]]; then
    mkdir -p .runtime
    CF_BIN=".runtime/cloudflared"
    if [[ ! -x "$CF_BIN" ]]; then
      OS="darwin"
      ARCH=$(uname -m)
      case "$ARCH" in
        arm64|aarch64) CF_URL="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-darwin-arm64.tgz" ;;
        x86_64|amd64)  CF_URL="https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-darwin-amd64.tgz" ;;
        *) echo "Unsupported architecture for cloudflared: $ARCH" 1>&2 ; exit 1 ;;
      esac
      echo "Downloading cloudflared…" 1>&2
      TMP_TGZ=".runtime/cloudflared.tgz"
      curl -fsSL "$CF_URL" -o "$TMP_TGZ"
      tar -xzf "$TMP_TGZ" -C .runtime > /dev/null 2>&1 || true
      rm -f "$TMP_TGZ"
      # Tar may extract to ./.runtime/cloudflared
      if [[ -f .runtime/cloudflared ]]; then
        chmod +x .runtime/cloudflared
      fi
    fi
    export PATH="$HERE/.runtime:$PATH"
  fi
fi

# Run the server (dotenv in server.js will pick up .env)
exec "$NODE_BIN" server.js
